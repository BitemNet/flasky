<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Summary Flask</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <article>
    <h1>Wstęp</h1>
    <h2>Jak pracować z przykładowym kodem</h2>
    <p>
        Repozytorium z historią zmian i przykładowymi kodami z książki:
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        Przełączanie między rewizjami, do tagu <em>1a</em>:
        <code>$ git chekout 1a</code>
        Będąc w stanie <strong>detached HEAD</strong> wprowadzone zmiany nie mają gdzie być
        zapisane. Resetowanie wprowadzonych zmian do wersji z commita:
        <code>$ git reset --hard</code>
        Synchronizowanie lokalnego repozytorium z originalnym z GitHuba:
        <code>$ git fetch --all</code>
        <code>$ git fetch --tags</code>
        <code>$ git reset --hard origin/master</code>
        Przegląd różnic występujących pomiędzy dwoma wersjami aplikacji:
        <code>$ git diff 2a 2b</code>
        Różnice między dwoma rewizjami na GitHubie:
        <code><a href="https://github.com/miguelgrinberg/flasky/compare/2a...2b">
            https://github.com/miguelgrinberg/flasky/compare/2a...2b
        </a></code>
    </p>
    </article>

    <article>
    <h1>Instalacja</h1>
    <h2>Tworzenie katalogu aplikacji</h2>
    <h3>Korzystając z klonu z GitHuba</h3>
    <p>
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        <code>$ cd flasky</code>
        <code>$ git checkout 1a</code>
    </p>
    <h3>Ograniczając się jedynie do lokalnego projektu</h3>
    <p>
        <code>$ mkdir flasky</code>
        <code>$ cd flasky</code>
    </p>
    <h2>Wirtualne środowiska</h2>
    <h3>Tworzenie wirtualnego środowiska w Python 3</h3>
    <p>
        Polecenie tworzące wirtualne środowisko o nazwie <em>.venv</em>:
        <code>$ python -m venv .venv</code>
    </p>
    <h3>Praca z wirtualnym środowiskiem</h3>
    <p>
        Aktywowanie wirtualnego środowiska:
        <code>$ source .venv/bin/activate  # w Linux</code>
        <code>&gt; .venv\Scripts\activate  # w Windows</code>
        Uruchamianie konsoli wirtualnego środowiska (w przypadku nie aktywowania wirtualnego
        środowiska):
        <code>$ .venv/bin/python  # w Linux</code>
        <code>&gt; venv\Sripts\python  # w Windows</code>
        Deaktywowanie wirtualnego środowiska:
        <code>$ deactivate  # w Linux</code>
        <code>&gt; deactivate  # w Windows</code>
    </p>
    <h2>Instalowanie pakietu Pythona</h2>
    <p>
        Instalacja pakietu <em>flask</em> oraz wszystkich jego zależności:
        <code>(.venv) $ pip install flask</code>
        Lista zainstalowanych pakietów:
        <code>(.venv) $ pip freeze</code>
        Proste sprawdzenie poprawności instalacji pakietu:
        <code>(.venv) $ python</code>
        <code>&gt;&gt;&gt; import flask</code>
        <code>&gt;&gt;&gt;</code>
    </p>
    </article>

    <article>
        <h1>Podstawowa struktura aplikacji</h1>


        <h2>Inicjalizacja</h2>
        <p>
            <span>Instancja aplikacji </span> jest obiektem klasy <span>Flask</span>

            <code>__name__</code> powrzechnie używana wartość
            <hr>
            <a href="#">Git</a>
        </p>
        <hr>
        <a href="#">Git</a>
    

        <h2>Trasy i funkcje widoku</h2>
        <p>
            Odwzorowanie adresów URL na funkcje Pythona (ang. <em lang="en">route</em>)
<pre>
@app.route('/')
def index():
    return "&lt;h1&gt;Hello, World!&lt;/h1&gt;"
</pre>
            Równoważny sposób rejestrowania funkcji widoku
            <pre>app.add_url_rule('/', 'index', index)</pre>
        </p>
        <p>
            Składnik dynamiczny adresu
<pre>
@app.route('/user/&lt;name&gt;')
def user(name):
    return f"&lt;h1&gt;Hello, {name}!&lt;/h1&gt;"
</pre>
            Dynamiczne komponenty w trasach mogą mieć różne typy
            <pre>&lt;name&gt; (lub &lt;string: name&gt; &mdash; wartość domyślna), &lt;int: id&gt;, &lt;float: f&gt;, &lt;path: p&gt;</pre>
        
            <hr>
            <a href="#">2_trasy_i_funkcje_widoku</a> ¤
            <a href="#">2_kompletna_app</a>
        </p>
    

        <h2>Roboczy serwer WWW</h2>
        <p>
            Uruchamianie serwera, najpierw ustawiamy zmienną środowiskową
            <code>(venv) $ export FLASK_APP=hello.py</code>
            <code>&gt; set FLASK_APP=hello.py  # Windows</code>
            <code>PS &gt $Env:FLASK_APP="hello.py"  # Windows PowerShell</code>
            <code>(venv) $ flask run</code>
            Inna metoda uruchamiania serwera
            <pre>app.run()</pre>
            Zatrzymanie serwera <kbd>Ctrl+C</kbd>
        </p>
        <p>
            Adres URL: <a href="http://localhost:5000">http://localhost:5000</a>
        </p>
        <p>
            W trybie debugowania serwer Flaska domyślnie włącza dwa moduły serwera:
            <em lang="en">reloader</em> i <em lang="en">debuger</em>
            <code>(venv) $ export FLASK_DEBUG=1</code>
            <code>PS &gt; $Env:FLASK_DEBUG=1  # Windows PowerShell</code>
            <code>(venv) $ flask run</code>
            W przypadku tradycyjnej metody uruchamiania serwera, moduł debugera włączamy>
            <pre>app.run(debug=True)</pre>
            Kodem PIN można zabezpieczyć przypadkowe uruchomienie debugera na serwerze produkcyjnym.
        </p>
        <p>
            Opcje wiersza poleceń polecenia <em>flask</em>
            <code>(venv) $ flask --help</code>
            Sesja powłoki Pythona w kontekście aplikacji
            <code>(venv) $ flask shell</code>
            Opcje wiersza poleceń polecenia <em>flask run</em>
            <code>(venv) $ flask run --help</code>
            Adres interfejsu sieciowego na jakim serwer nasłuchuje połączeń od klientów:<br>
            - domyślnie 127.0.0.1 (localhost), na tym samym komputerze
            <code>(venv) $ flask run</code>
            - w całej sieci, serwer widoczny pod adresem komputera
            na którym został uruchomiony <em>http://a.b.c.d:5000</em>
            <code>(venv) $ flask run --host 0.0.0.0</code>
        </p>

        <h2>Cykl żądanie - odpowiedź</h2>
        <p>
            Konteksty umożliwiają Flaskowi globalne udostępnianie wątkowi pewnych zmiennych
            bez ingerencji w inne wątki, tu na przykładzie obiektu <em>request</em>
<pre>
@app.route('/browser')
def browser():
    user_agent = request.headers.get('User-Agent')
    return f"&lt;p&gt;Twoją przeglądarką jest {user_agent}&lt;/p&gt;"
</pre>
            <hr>
            <a href="https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">
                https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks
            </a><br>
            <a href="https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html">
                https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html
            </a><br>
            <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">
                https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
            </a>
        </p>
    </article>

    <article>
        <h1>Szablony</h1>

        <h2>Mechanizm szablonów Jinja2</h2>
        <p>
            Szablon to plik tekstowy odpowiedzi funkcji widoku. Domyślnie szablony są w
            folderze <em>templates</em>
<pre><i><u>file: templates/index.html</u></i>
&lt;h1&gt;Hello, World!&lt;/h1&gt;
</pre>
<pre><i><u>file: templates/user.html</u></i>
&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
</pre>
        </p>

        <h3>Renderowanie szablonów</h3>
<pre><i><u>file: hello.py</u></i>
from flask import <b>render_template</b>
&hellip;
@app.route('/')
def index():
    return <b>render_template('index.html')</b>
@app.route('/user/&lt;name&gt;')
def user(name):
    return <b>render_template('user.html', name=name)</b>
</pre>

        <h3>Zmienne</h3>
        <p>
            Jinja2 rozpoznaje zmienne dowolnego typu, nawet złożonego
<pre>
&lt;p&gt;Wartość <b>{{ myobj.somemethod() }}, {{ mylist[id] }}</b>&lt;/p&gt;
</pre>
        </p>
        <p>
            Zmienne można modyfikować za pomocą <em>filtrów</em>
<pre>
&lt;p&gt;Hello <b>{{ name|capitalize }}</b>&lt;/p&gt;
</pre>
            Lista wybranych filtrów
            <ul>
                <li><strong>safe</strong> &mdash; renderuje wartość bez interpretowania znaków modyfikacji; interpretuje znaczniki HTML</li>
                <li><strong>capitalize</strong> &mdash; zmienia pierwszy znak wartości na wielką literą, a pozostałe na małe</li>
                <li><strong>lower</strong> &mdash; zmienia tekst na małe litery</li>
                <li><strong>upper</strong> &mdash; zmienia tekst na duże litery</li>
                <li><strong>title</strong> &mdash; pierwsza litera każdego słowa zapisana jest wielką literą</li>
                <li><strong>trim</strong> &mdash; usuwa białe znaki z początku i końca</li>
                <li><strong>striptags</strong> &mdash; przed renderowaniem usuwa z wartości wszystkie znaczniki HTML</li>
                <li><a href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters">see doc</a></li>
            </ul>
        </p>

        <h3>Struktury sterujące</h3>
        <p>
            <u>Instrukcja warunkowa</u>
<pre>
{% if user %}
    Witaj {{ user }}!
{% else %}
    Witaj, nieznajomy!
{% endif %}
</pre>
            <u>Pętla <em>for</em></u>
<pre>
&lt;ul&gt;
    {% for comment in comments %}
        &lt;li&gt;{{ comment }}&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w tym samym pliku</u>
<pre>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}

&lt;ul&gt;
    {% for comment in comments %}
    {{ render_comment(comment) }}
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w osobnym pliku</u>
<pre><i><u>file: templates/macros.html</u></i>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}
</pre>
<pre><i><u>file: templates/index.html</u></i>
{% import 'macros.html' as macros %}
&lt;ul&gt;
{% for comment in comments %}
    {{ render_comment(comment) }}
{% endfor %}
&lt;/ul&gt;
</pre>
            <u>Wielokrotnie używany kod szablonu można zapisać w osobnym pliku i dołączać w innych miejscach</u>
<pre>
{% include 'common.html' %}
</pre>
            <u>Dziedziczenie szablonów</u><br>
            Szablon podstawowy
<pre><i><u>file: templates/base.html</u></i>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
{% block head %}
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{% block title %}{% endblock %} - Moja aplikacja&lt;/title&gt;
{% endblock %}
&lt;/head&gt;
&lt;body&gt;
    {% block body %}
    {% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</pre>
            Szablon wywiedziony (dziedziczący) z szablonu podstawowego
<pre>
{% extends "tmp/base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    &lt;style&gt;
    &lt;/style&gt;
{% endblock %}
{% block body %}
&lt;h1&gt;Witaj, {{ user }}?&lt;/h1&gt;
{% endblock %}
</pre>
            Bloki mogą być zagnieżdżone. Funkcja <em>super()</em> odwołuje się do zawartości bloku w szablonie bazowym.
        </p>


        <h2>Integracja Bootstrap z Flask-Bootstrap</h2>
        <p>
            <a href="https://getbootstrap.com/">https://getbootstrap.com/</a><br>
            Instalacja w wirtualnym środowisku
            <code>
                (venv) $ pip install flask-bootstrap
            </code>
            Inicjalizacja rozszerzenia Flask-Bootstrap
<pre>
from flask_bootstrap import Bootstrap
&hellip;
bootstrap = Bootstrap(app)
</pre>
        </p>
        <p>
            Aplikacja uzyskuje dostęp do szablonu bazowego Bootstrap'a
<pre><i><u>file: templates/user.html</u></i>
{% extends "bootstrap/base.html" %}
{% block title %}My Title{% endblock %}
{% block navbar %}&hellip;{% endblock %}
{% block content %}&hellip;{% endblock %}
&lt;!-- Bootstrap definiuje również inne bloki  --&gt;
</pre>
        </p>
        <p>
            Aby nie nadpisać domyślnej zawartości bloków Bootstrapa, należy
            użyć <em>super()</em>
<pre>
{% extends "bootstrap/base.html" %}
{% block scripts %}
{{ super() }}
&lt;script type="text/javascript" src="my-script.js"&gt;&lt;/script&gt;
{% endblock %}
</pre>
        </p>


        <h2>Niestandardowe strony błędów</h2>
        <p>
            Obsługa przykładowych błędów
<pre>
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500
</pre>
        </p>
        <p>
            Aby nie powielać kodu, strony <em>404.html</em> i <em>500.html</em>
            mogą dziedziczyć z szablonu bazowego
            dla całego serwisu <em>template/base.html</em>, a ten z kolei powinien
            dziedziczyć z szablonu bazowego Bootstrapa <em>bootstrap/base.html</em>.
        </p>


        <h2>Łącza</h2>
        <p>
            Funkcja <em>url_for()</em> generuje adres URL na podstawie
            informacji przechowywanych w mapie adresów.
<pre>
url_for('index')  # '/'
url_for('index', _external=True)  # 'http://localhost:5000/'
url_for('user', name='janusz', _external=True)  # http://localhost:5000/user/janusz
url_for('user', name='admin', page=2, version=1)  # '/user/admin?page=2&version=1'
</pre>
        </p>


        <h2>Pliki statyczne</h2>
        <p>
            Flask domyślnie szuka plików statycznych w podkatalogu <em>/static/</em>.
            Przykładowo dodanie favicon
<pre><i><u>file: templates/base.html</u></i>
{% block head %}
{{ super() }}
&lt;link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon"&gt;
{% endblock %}
</pre>
        </p>


        <h2>Lokalizowanie dat i czasu za pomocą pakietu <em>Flask-Moment</em></h2>
        <p>
            <strong>Flask-moment</strong>, to rozszerzenie, które integruje
            bibliotekę <em>Moment.js</em> z szablonami <em>Jinja2</em>. Do
            działania potrzebuje jeszcze pakietu <em>jQuery.js</em>, który
            dostarcza choćby Bootstrap.
        </p>
        <p>
            Instalacja pakietu <a href="https://momentjs.com">Flask-moment</a>
            <code>(venv) $ pip install flask-moment</code>
        </p>
        <p>
            Inicjowanie pakietu
<pre>
from flask_moment import Moment
app = Flask(__name__)
moment = Moment(app)
</pre>
        </p>
        <p>
            Importowanie biblioteki <em>Moment.js</em> do szablonu.
            <em>local('pl')</em> określa regionalizację.
            Pakiet <em>Flask-moment</em> udostępnia szablonom obiekt <em>moment</em>
            umożliwiający pracę ze znacznikami czasu.
<pre><i><u>file: templates/base.html</u></i>
{% block scripts %}
{{ super() }}
{{ moment.include_moment() }}
{{ moment.locale('pl')}}
{% endblock %}
</pre>
        </p>
        <p>
            Czas uniwersalny UTC jest przekazywany do szablonu
<pre>
from datetime import datetime, UTC
@app.route('/time')
def show_time():
    return render_template('time.html', current_time=datetime.now(UTC))
</pre>
        a w szablonie jest renderowany na czas lokalny
<pre>
&lt;p&gt;Lokalna data i czas: {{ moment(current_time).format('LLL') }}.&lt;/p&gt;
&lt;p&gt;To było {{ moment(current_time).fromNow(refresh=True) }}&lt;/p&gt;
</pre>
        </p>
        <p>
            <a href="https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated">
                naive datetime object
            </a><br>
            <a href="https://en.wikipedia.org/wiki/ISO_3166-1">
                kody regionalizacji
            </a><br>
            <a href="https://momentjs.com/docs/#/displaying/">
                Moment.js formatowanie
            </a>
        </p>

    </article>
</body>
</html>

