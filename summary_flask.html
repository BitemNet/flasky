<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Summary Flask</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <article>
    <h1>Wstęp</h1>
    <h2>Jak pracować z przykładowym kodem</h2>
    <p>
        Repozytorium z historią zmian i przykładowymi kodami z książki:
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        Przełączanie między rewizjami, do tagu <em>1a</em>:
        <code>$ git chekout 1a</code>
        Będąc w stanie <strong>detached HEAD</strong> wprowadzone zmiany nie mają gdzie być
        zapisane. Resetowanie wprowadzonych zmian do wersji z commita:
        <code>$ git reset --hard</code>
        Synchronizowanie lokalnego repozytorium z originalnym z GitHuba:
        <code>$ git fetch --all</code>
        <code>$ git fetch --tags</code>
        <code>$ git reset --hard origin/master</code>
        Przegląd różnic występujących pomiędzy dwoma wersjami aplikacji:
        <code>$ git diff 2a 2b</code>
        Różnice między dwoma rewizjami na GitHubie:
        <code><a href="https://github.com/miguelgrinberg/flasky/compare/2a...2b">
            https://github.com/miguelgrinberg/flasky/compare/2a...2b
        </a></code>
    </p>
    </article>

    <article>
    <h1>Instalacja</h1>
    <h2>Tworzenie katalogu aplikacji</h2>
    <h3>Korzystając z klonu z GitHuba</h3>
    <p>
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        <code>$ cd flasky</code>
        <code>$ git checkout 1a</code>
    </p>
    <h3>Ograniczając się jedynie do lokalnego projektu</h3>
    <p>
        <code>$ mkdir flasky</code>
        <code>$ cd flasky</code>
    </p>
    <h2>Wirtualne środowiska</h2>
    <h3>Tworzenie wirtualnego środowiska w Python 3</h3>
    <p>
        Polecenie tworzące wirtualne środowisko o nazwie <em>.venv</em>:
        <code>$ python -m venv .venv</code>
    </p>
    <h3>Praca z wirtualnym środowiskiem</h3>
    <p>
        Aktywowanie wirtualnego środowiska:
        <code>$ source .venv/bin/activate  # w Linux</code>
        <code>&gt; .venv\Scripts\activate  # w Windows</code>
        Uruchamianie konsoli wirtualnego środowiska (w przypadku nie aktywowania wirtualnego
        środowiska):
        <code>$ .venv/bin/python  # w Linux</code>
        <code>&gt; venv\Sripts\python  # w Windows</code>
        Deaktywowanie wirtualnego środowiska:
        <code>$ deactivate  # w Linux</code>
        <code>&gt; deactivate  # w Windows</code>
    </p>
    <h2>Instalowanie pakietu Pythona</h2>
    <p>
        Instalacja pakietu <em>flask</em> oraz wszystkich jego zależności:
        <code>(.venv) $ pip install flask</code>
        Lista zainstalowanych pakietów:
        <code>(.venv) $ pip freeze</code>
        Proste sprawdzenie poprawności instalacji pakietu:
        <code>(.venv) $ python</code>
        <code>&gt;&gt;&gt; import flask</code>
        <code>&gt;&gt;&gt;</code>
    </p>
    </article>

    <article>
        <h1>Podstawowa struktura aplikacji</h1>


        <h2>Inicjalizacja</h2>
        <p>
            <span>Instancja aplikacji </span> jest obiektem klasy <span>Flask</span>

            <code>__name__</code> powrzechnie używana wartość
            <hr>
            <a href="#">Git</a>
        </p>
        <hr>
        <a href="#">Git</a>
    

        <h2>Trasy i funkcje widoku</h2>
        <p>
            Odwzorowanie adresów URL na funkcje Pythona (ang. <em lang="en">route</em>)
<pre>
@app.route('/')
def index():
    return "&lt;h1&gt;Hello, World!&lt;/h1&gt;"
</pre>
            Równoważny sposób rejestrowania funkcji widoku
            <pre>app.add_url_rule('/', 'index', index)</pre>
        </p>
        <p>
            Składnik dynamiczny adresu
<pre>
@app.route('/user/&lt;name&gt;')
def user(name):
    return f"&lt;h1&gt;Hello, {name}!&lt;/h1&gt;"
</pre>
            Dynamiczne komponenty w trasach mogą mieć różne typy
            <pre>&lt;name&gt; (lub &lt;string: name&gt; &mdash; wartość domyślna), &lt;int: id&gt;, &lt;float: f&gt;, &lt;path: p&gt;</pre>
        
            <hr>
            <a href="#">2_trasy_i_funkcje_widoku</a> ¤
            <a href="#">2_kompletna_app</a>
        </p>
    

        <h2>Roboczy serwer WWW</h2>
        <p>
            Uruchamianie serwera, najpierw ustawiamy zmienną środowiskową
            <code>(venv) $ export FLASK_APP=hello.py</code>
            <code>&gt; set FLASK_APP=hello.py  # Windows</code>
            <code>(venv) $ flask run</code>
            Inna metoda uruchamiania serwera
            <pre>app.run()</pre>
            Zatrzymanie serwera <kbd>Ctrl+C</kbd>
        </p>
        <p>
            Adres URL: <a href="http://localhost:5000">http://localhost:5000</a>
        </p>
        <p>
            W trybie debugowania serwer Flaska domyślnie włącza dwa moduły serwera:
            <em lang="en">reloader</em> i <em lang="en">debuger</em>
            <code>(venv) $ export FLASK_DEBUG=1</code>
            <code>(venv) $ flask run</code>
            W przypadku tradycyjnej metody uruchamiania serwera, moduł debugera włączamy>
            <pre>app.run(debug=True)</pre>
            Kodem PIN można zabezpieczyć przypadkowe uruchomienie debugera na serwerze produkcyjnym.
        </p>
        <p>
            Opcje wiersza poleceń polecenia <em>flask</em>
            <code>(venv) $ flask --help</code>
            Sesja powłoki Pythona w kontekście aplikacji
            <code>(venv) $ flask shell</code>
            Opcje wiersza poleceń polecenia <em>flask run</em>
            <code>(venv) $ flask run --help</code>
            Adres interfejsu sieciowego na jakim serwer nasłuchuje połączeń od klientów:<br>
            - domyślnie 127.0.0.1 (localhost), na tym samym komputerze
            <code>(venv) $ flask run</code>
            - w całej sieci, serwer widoczny pod adresem komputera
            na którym został uruchomiony <em>http://a.b.c.d:5000</em>
            <code>(venv) $ flask run --host 0.0.0.0</code>
        </p>

        <h2>Cykl żądanie - odpowiedź</h2>
        <p>
            Konteksty umożliwiają Flaskowi globalne udostępnianie wątkowi pewnych zmiennych
            bez ingerencji w inne wątki, tu na przykładzie obiektu <em>request</em>
<pre>
@app.route('/browser')
def browser():
    user_agent = request.headers.get('User-Agent')
    return f"&lt;p&gt;Twoją przeglądarką jest {user_agent}&lt;/p&gt;"
</pre>
            <hr>
            <a href="https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">
                https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks
            </a><br>
            <a href="https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html">
                https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html
            </a><br>
            <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">
                https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
            </a>
        </p>
    </article>

    <article>
        <h1>Szablony</h1>

        <h2>Mechanizm szablonów Jinja2</h2>
        <p>
            Szablon to plik tekstowy odpowiedzi funkcji widoku. Domyślnie szablony są w
            folderze <em>templates</em>
<pre><i><u>file: templates/index.html</u></i>
&lt;h1&gt;Hello, World!&lt;/h1&gt;
</pre>
<pre><i><u>file: templates/user.html</u></i>
&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
</pre>
        </p>

        <h3>Renderowanie szablonów</h3>
<pre><i><u>file: hello.py</u></i>
from flask import <b>render_template</b>
&hellip;
@app.route('/')
def index():
    return <b>render_template('index.html')</b>
@app.route('/user/&lt;name&gt;')
def user(name):
    return <b>render_template('user.html', name=name)</b>
</pre>

        <h3>Zmienne</h3>
        <p>
            Jinja2 rozpoznaje zmienne dowolnego typu, nawet złożonego
<pre>
&lt;p&gt;Wartość <b>{{ myobj.somemethod() }}, {{ mylist[id] }}</b>&lt;/p&gt;
</pre>
        </p>
        <p>
            Zmienne można modyfikować za pomocą <em>filtrów</em>
<pre>
&lt;p&gt;Hello <b>{{ name|capitalize }}</b>&lt;/p&gt;
</pre>
            Lista wybranych filtrów
            <ul>
                <li><strong>safe</strong> &mdash; renderuje wartość bez interpretowania znaków modyfikacji; interpretuje znaczniki HTML</li>
                <li><strong>capitalize</strong> &mdash; zmienia pierwszy znak wartości na wielką literą, a pozostałe na małe</li>
                <li><strong>lower</strong> &mdash; zmienia tekst na małe litery</li>
                <li><strong>upper</strong> &mdash; zmienia tekst na duże litery</li>
                <li><strong>title</strong> &mdash; pierwsza litera każdego słowa zapisana jest wielką literą</li>
                <li><strong>trim</strong> &mdash; usuwa białe znaki z początku i końca</li>
                <li><strong>striptags</strong> &mdash; przed renderowaniem usuwa z wartości wszystkie znaczniki HTML</li>
                <li><a href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters">see doc</a></li>
            </ul>
        </p>

        <h3>Struktury sterujące</h3>
        <p>
            <u>Instrukcja warunkowa</u>
<pre>
{% if user %}
    Witaj {{ user }}!
{% else %}
    Witaj, nieznajomy!
{% endif %}
</pre>
            <u>Pętla <em>for</em></u>
<pre>
&lt;ul&gt;
    {% for comment in comments %}
        &lt;li&gt;{{ comment }}&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w tym samym pliku</u>
<pre>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}

&lt;ul&gt;
    {% for comment in comments %}
    {{ render_comment(comment) }}
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w osobnym pliku</u>
<pre><i><u>file: templates/macros.html</u></i>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}
</pre>
<pre><i><u>file: templates/index.html</u></i>
{% import 'macros.html' as macros %}
&lt;ul&gt;
{% for comment in comments %}
    {{ render_comment(comment) }}
{% endfor %}
&lt;/ul&gt;
</pre>
            <u>Wielokrotnie używany kod szablonu można zapisać w osobnym pliku i dołączać w innych miejscach</u>
<pre>
{% include 'common.html' %}
</pre>
            <u>Dziedziczenie szablonów</u><br>
            Szablon podstawowy
<pre><i><u>file: templates/base.html</u></i>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
{% block head %}
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{% block title %}{% endblock %} - Moja aplikacja&lt;/title&gt;
{% endblock %}
&lt;/head&gt;
&lt;body&gt;
    {% block body %}
    {% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</pre>
            Szablon wywiedziony (dziedziczący) z szablonu podstawowego
<pre>
{% extends "tmp/base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    &lt;style&gt;
    &lt;/style&gt;
{% endblock %}
{% block body %}
&lt;h1&gt;Witaj, {{ user }}?&lt;/h1&gt;
{% endblock %}
</pre>
            Bloki mogą być zagnieżdżone. Funkcja <em>super()</em> odwołuje się do zawartości bloku w szablonie bazowym.
        </p>


        <h2>Integracja Bootstrap z Flask-Bootstrap</h2>
        <p>
            <a href="https://getbootstrap.com/">https://getbootstrap.com/</a><br>
            Instalacja w wirtualnym środowisku
            <code>
                (venv) $ pip install flask-bootstrap
            </code>
            Inicjalizacja rozszerzenia Flask-Bootstrap
<pre>
from flask_bootstrap import Bootstrap
&hellip;
bootstrap = Bootstrap(app)
</pre>
        </p>

    </article>
</body>
</html>

