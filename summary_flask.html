<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Summary Flask</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <article>
    <h1>Wstęp</h1>
    <h2>Jak pracować z przykładowym kodem</h2>
    <p>
        Repozytorium z historią zmian i przykładowymi kodami z książki:
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        Przełączanie między rewizjami, do tagu <em>1a</em>:
        <code>$ git chekout 1a</code>
        Będąc w stanie <strong>detached HEAD</strong> wprowadzone zmiany nie mają gdzie być
        zapisane. Resetowanie wprowadzonych zmian do wersji z commita:
        <code>$ git reset --hard</code>
        Synchronizowanie lokalnego repozytorium z originalnym z GitHuba:
        <code>$ git fetch --all</code>
        <code>$ git fetch --tags</code>
        <code>$ git reset --hard origin/master</code>
        Przegląd różnic występujących pomiędzy dwoma wersjami aplikacji:
        <code>$ git diff 2a 2b</code>
        Różnice między dwoma rewizjami na GitHubie:
        <code><a href="https://github.com/miguelgrinberg/flasky/compare/2a...2b">
            https://github.com/miguelgrinberg/flasky/compare/2a...2b
        </a></code>
    </p>
    </article>

    <article>
    <h1>Instalacja</h1>
    <h2>Tworzenie katalogu aplikacji</h2>
    <h3>Korzystając z klonu z GitHuba</h3>
    <p>
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        <code>$ cd flasky</code>
        <code>$ git checkout 1a</code>
    </p>
    <h3>Ograniczając się jedynie do lokalnego projektu</h3>
    <p>
        <code>$ mkdir flasky</code>
        <code>$ cd flasky</code>
    </p>
    <h2>Wirtualne środowiska</h2>
    <h3>Tworzenie wirtualnego środowiska w Python 3</h3>
    <p>
        Polecenie tworzące wirtualne środowisko o nazwie <em>.venv</em>:
        <code>$ python -m venv .venv</code>
    </p>
    <h3>Praca z wirtualnym środowiskiem</h3>
    <p>
        Aktywowanie wirtualnego środowiska:
        <code>$ source .venv/bin/activate  # w Linux</code>
        <code>&gt; .venv\Scripts\activate  # w Windows</code>
        Uruchamianie konsoli wirtualnego środowiska (w przypadku nie aktywowania wirtualnego
        środowiska):
        <code>$ .venv/bin/python  # w Linux</code>
        <code>&gt; venv\Sripts\python  # w Windows</code>
        Deaktywowanie wirtualnego środowiska:
        <code>$ deactivate  # w Linux</code>
        <code>&gt; deactivate  # w Windows</code>
    </p>
    <h2>Instalowanie pakietu Pythona</h2>
    <p>
        Instalacja pakietu <em>flask</em> oraz wszystkich jego zależności:
        <code>(.venv) $ pip install flask</code>
        Lista zainstalowanych pakietów:
        <code>(.venv) $ pip freeze</code>
        Proste sprawdzenie poprawności instalacji pakietu:
        <code>(.venv) $ python</code>
        <code>&gt;&gt;&gt; import flask</code>
        <code>&gt;&gt;&gt;</code>
    </p>
    </article>

    <article>
        <h1>Podstawowa struktura aplikacji</h1>


        <h2>Inicjalizacja</h2>
        <p>
            <span>Instancja aplikacji </span> jest obiektem klasy <span>Flask</span>

            <code>__name__</code> powrzechnie używana wartość
            <hr>
            <a href="#">Git</a>
        </p>
        <hr>
        <a href="#">Git</a>
    

        <h2>Trasy i funkcje widoku</h2>
        <p>
            Odwzorowanie adresów URL na funkcje Pythona (ang. <em lang="en">route</em>)
<pre>
@app.route('/')
def index():
    return "&lt;h1&gt;Hello, World!&lt;/h1&gt;"
</pre>
            Równoważny sposób rejestrowania funkcji widoku
            <pre>app.add_url_rule('/', 'index', index)</pre>
        </p>
        <p>
            Składnik dynamiczny adresu
<pre>
@app.route('/user/&lt;name&gt;')
def user(name):
    return f"&lt;h1&gt;Hello, {name}!&lt;/h1&gt;"
</pre>
            Dynamiczne komponenty w trasach mogą mieć różne typy
            <pre>&lt;name&gt; (lub &lt;string: name&gt; &mdash; wartość domyślna), &lt;int: id&gt;, &lt;float: f&gt;, &lt;path: p&gt;</pre>
        
            <hr>
            <a href="#">2_trasy_i_funkcje_widoku</a> ¤
            <a href="#">2_kompletna_app</a>
        </p>
    

        <h2>Roboczy serwer WWW</h2>
        <p>
            Uruchamianie serwera, najpierw ustawiamy zmienną środowiskową
            <code>(venv) $ export FLASK_APP=hello.py</code>
            <code>&gt; set FLASK_APP=hello.py  # Windows</code>
            <code>(venv) $ flask run</code>
            Inna metoda uruchamiania serwera
            <pre>app.run()</pre>
            Zatrzymanie serwera <kbd>Ctrl+C</kbd>
        </p>
        <p>
            Adres URL: <a href="http://localhost:5000">http://localhost:5000</a>
        </p>
        <p>
            W trybie debugowania serwer Flaska domyślnie włącza dwa moduły serwera:
            <em lang="en">reloader</em> i <em lang="en">debuger</em>
            <code>(venv) $ export FLASK_DEBUG=1</code>
            <code>(venv) $ flask run</code>
            W przypadku tradycyjnej metody uruchamiania serwera, moduł debugera włączamy>
            <pre>app.run(debug=True)</pre>
            Kodem PIN można zabezpieczyć przypadkowe uruchomienie debugera na serwerze produkcyjnym.
        </p>
        <p>
            Opcje wiersza poleceń polecenia <em>flask</em>
            <code>(venv) $ flask --help</code>
            Sesja powłoki Pythona w kontekście aplikacji
            <code>(venv) $ flask shell</code>
            Opcje wiersza poleceń polecenia <em>flask run</em>
            <code>(venv) $ flask run --help</code>
            Adres interfejsu sieciowego na jakim serwer nasłuchuje połączeń od klientów:<br>
            - domyślnie 127.0.0.1 (localhost), na tym samym komputerze
            <code>(venv) $ flask run</code>
            - w całej sieci, serwer widoczny pod adresem komputera
            na którym został uruchomiony <em>http://a.b.c.d:5000</em>
            <code>(venv) $ flask run --host 0.0.0.0</code>
        </p>

        <h2>Cykl żądanie - odpowiedź</h2>
        <p>
            Konteksty umożliwiają Flaskowi globalne udostępnianie wątkowi pewnych zmiennych
            bez ingerencji w inne wątki, tu na przykładzie obiektu <em>request</em>
<pre>
@app.route('/browser')
def browser():
    user_agent = request.headers.get('User-Agent')
    return f"&lt;p&gt;Twoją przeglądarką jest {user_agent}&lt;/p&gt;"
</pre>
            <hr>
            <a href="https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">
                https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks
            </a><br>
            <a href="https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html">
                https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html
            </a><br>
            <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">
                https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
            </a>
        </p>
    </article>

    <article>
        <h1>Szablony</h1>


        <h2>Inicjalizacja</h2>
        <p>
        </p>
    </article>
</body>
</html>

